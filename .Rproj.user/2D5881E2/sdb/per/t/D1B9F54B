{
    "contents" : "\n\n\n######################################\n########### MAIN FUNCTIONS ###########\n######################################\n\n\nPointsOpport <- function(knownpts,\n                         varname,\n                         span,\n                         beta,\n                         mask = NULL, \n                         typedist = \"euclidean\", \n                         typefct = \"exponential\", \n                         resolution = 200)\n{\n  if(is.projected(knownpts) == FALSE) {\n    stop(\"Your input (knownpts) isn't a spatial object or isn't projected\")\n  }\n  \n  getproj <- proj4string(knownpts)\n  unknownpts <- CreateGrid(knownpts = knownpts, mask = mask, resolution = resolution)\n  matdist <- GetDistMat(knownpts = knownpts, unknownpts = unknownpts, typedist = typedist)\n  interact <- ComputeInteractDensity(matdist = matdist, unknownpts = unknownpts, typefct = typefct, beta = beta, span = span)\n  unknownpts <- interact$PTS\n  matdens <- interact$MAT\n  matopport <- ComputeOpportunity(knownpts = knownpts, matdens = matdens, varname = varname)\n  return(list(UNKWPTS = unknownpts, OPPORT = matopport, PROJ = getproj))\n}\n\nOpportPotentials <- function(opportgrid, nbclass = 8, mask = NULL)\n{\n  polyPot <- ComputePotentials(unknownpts = opportgrid$UNKWPTS, \n                               matopport = opportgrid$OPPORT, \n                               myproj = opportgrid$PROJ,\n                               nbclass = nbclass, \n                               mask = mask)\n  return(polyPot)\n}\n\n\n# Discretize and map ----\n\n\n\n\n######################################\n######## BACKGROUND FUNCTIONS ########\n######################################\n\n# Create grid of unknown points ----\n\nCreateGrid <- function (knownpts, mask, resolution)\n{\n  coordPts <- data.frame(COORDX = coordinates(knownpts)[, 1], COORDY = coordinates(knownpts)[, 2], stringsAsFactors = FALSE)\n  spatSteps <- ifelse(max(coordPts[ , \"COORDX\"]) - min(coordPts[ , \"COORDX\"]) >= max(coordPts[ , \"COORDY\"]) - min(coordPts[ , \"COORDY\"]),\n                      round((max(coordPts[ , \"COORDX\"]) - min(coordPts[ , \"COORDX\"])) / resolution, digits = 4),\n                      round((max(coordPts[ , \"COORDY\"]) - min(coordPts[ , \"COORDY\"])) / resolution, digits = 4))\n  \n  if(is.null(mask)){\n    boundingBox <- bbox(knownpts)\n  } else {\n    boundingBox <- bbox(mask)\n  }\n  \n  boxCoordX <- round(seq(boundingBox[1, 1] - spatSteps, boundingBox[1, 2] + spatSteps, spatSteps), digits = 4)\n  boxCoordY <- round(seq(boundingBox[2, 1] - spatSteps, boundingBox[2, 2] + spatSteps, spatSteps), digits = 4)\n  spatGrid <- expand.grid(boxCoordX, boxCoordY)\n  idSeq <- seq(1, nrow(spatGrid), 1)\n  spatGrid <- data.frame(ID = idSeq, COORDX = spatGrid[, 1], COORDY = spatGrid[, 2])\n  return(spatGrid)\n}\n\n\n# Compute matrix of distances ----\n\nGetDistMat <- function(knownpts, unknownpts, typedist)\n{\n  knownPts <- data.frame(COORDX = coordinates(knownpts)[, 1], COORDY = coordinates(knownpts)[, 2], stringsAsFactors = FALSE)\n  \n  if(typedist == \"euclidean\") {\n    matDist <- rdist(knownPts[ , c(\"COORDX\", \"COORDY\")], unknownpts[ , c(\"COORDX\", \"COORDY\")])\n  } else if(typedist == \"orthodromic\") {\n    # x = longitud, y = latitud (decimal, WGS84)\n    matDist <- rdist.earth(knownPts[ , c(\"COORDX\", \"COORDY\")], unknownpts[ , c(\"COORDX\", \"COORDY\")], miles = FALSE, R = NULL)\n  } else {\n    stop(\"Please choose a valid distance argument (typedist)\")\n  }\n  \n  diag(matDist) <- 0 \n  return(round(matDist, digits = 8))\n}\n\n\n# Compute density of interaction ----\n\nComputeInteractDensity <- function(matdist, unknownpts, typefct, beta, span)\n{\n  if(typefct == \"pareto\") {\n    alpha  <- (2 ^ (1 / beta) - 1) / span\n    matDens <- (1 + alpha * matdist) ^ (-beta)\n  } else if(typefct == \"exponential\") {\n    alpha  <- log(2) / span ^ beta\n    matDens <- exp(- alpha * matdist ^ beta)\n  } else {\n    stop(\"Please choose a valid interaction function argument (typefct)\")\n  }\n  \n  diag(matDens) <- 1\n  matDens <- round(matDens, digits = 8)\n  unknownpts$MAXDENSITY <- apply(matDens, 2, max, na.rm = TRUE)\n  \n  return(list(PTS = unknownpts, MAT = matDens))\n}\n\n\n# Compute opportunities ----\n\nComputeOpportunity <- function(knownpts, matdens, varname = varname)\n{\n  matOpport <- knownpts@data[, varname] * matdens\n  return(round(matOpport, digits = 8))\n}\n\n\n# Compute potentials ----\n\nComputePotentials <- function(unknownpts, matopport, nbclass, mask, myproj)\n{\n  # compute potentials and create raster\n  unknownpts$POTENTIALS <- apply(matopport, 2, sum, na.rm = TRUE)\n  equalInterval <- (max(unknownpts$POTENTIALS) - min(unknownpts$POTENTIALS)) / nbclass\n  brksVal <- seq(min(unknownpts$POTENTIALS), max(unknownpts$POTENTIALS), equalInterval)\n  \n  unknownpts$POTDISCRET <- as.integer(cut(unknownpts$POTENTIALS, \n                                          breaks = brksVal,\n                                          labels = seq(1, nbclass, 1), \n                                          right = FALSE, \n                                          include.lowest = TRUE))\n  \n  spatUnknownPts <- SpatialPointsDataFrame(coords = unknownpts[ , c(2, 3)], \n                                           data = unknownpts, \n                                           proj4string = CRS(myproj))\n\n  rastGrid <- raster(xmn = min(unknownpts$COORDX), \n                     xmx = max(unknownpts$COORDX),\n                     ymn = min(unknownpts$COORDY),\n                     ymx = max(unknownpts$COORDY),\n                     nrows = length(unique(unknownpts$COORDY)),\n                     ncols = length(unique(unknownpts$COORDX)),\n                     crs = CRS(myproj))\n  \n  rastFilled <- rasterize(spatUnknownPts, rastGrid, field = \"POTDISCRET\")\n  \n  if(!is.null(mask)){\n    rastFilled <- mask(rastFilled, mask = mask)\n  }\n  \n  getPoly <- rasterToPolygons(rastFilled, n = 8, digits = 16, dissolve = TRUE)\n  return(getPoly)\n}\n\n\n\n\n",
    "created" : 1421967601041.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2495400167",
    "id" : "D1B9F54B",
    "lastKnownWriteTime" : 1421992339,
    "path" : "~/Repositories/StewartPotentials/Potentials_functions.R",
    "project_path" : "Potentials_functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}