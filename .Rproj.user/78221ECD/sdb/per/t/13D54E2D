{
    "contents" : "\n# This function compute the potentials of spatial interaction as defined by J.Q. Stewart\n\n\n\n# load packages ----\n\nlibrary(sp)\nlibrary(rgdal)\nlibrary(rgeos)\nlibrary(raster)\nlibrary(fields)\n\n\n# load data ----\n\nspatPts <- readOGR(dsn = \"parispc_pts.shp\", layer = \"parispc_pts\", stringsAsFactors = FALSE)\nspatUnits <- readOGR(dsn = \"parispc_com.shp\", layer = \"parispc_com\", stringsAsFactors = FALSE)\nspatMask <- readOGR(dsn = \"parispc_mask.shp\", layer = \"parispc_mask\", stringsAsFactors = FALSE)\n\nplot(spatMask)\nplot(spatUnits)\nplot(spatPts, add = T)\n\n\n\nsystem.time(\n  myGrid <- CreateGrid(spatpts = spatPts, mask = spaceBound, resolution = 500)\n)\nsystem.time(\n  myDistMat <- GetDistMat(knownpts = spatPts, unknownpts = myGrid, typedist = \"euclidean\")\n)\nsystem.time(\n  myInteract <- ComputeInteractDensity(matdist = myDistMat, unknownpts = myGrid, typefct = \"exponential\", beta = 3, span = 1000)\n)\nmyGrid <- myInteract[[1]]\nmyDensMat <- myInteract[[2]]\n\nsystem.time(\n  myOpport <- ComputeOpportunity(knownpts = spatPts, matdens = myDensMat, varname = \"EFF\")\n)\nsystem.time(\n  myPotentials <- ComputePotentials(unknownpts = myGrid, matopport = myOpport, nbclass = 8, mask = spaceBound, myproj = getProj)\n)\n\nwriteOGR(obj = myPotentials, dsn = \"test3\", layer = \"myPotentials\", driver = \"ESRI Shapefile\")\nwriteOGR(obj = myPotentials, dsn = \"test3\", layer = \"myPotentials\", driver = \"ESRI Shapefile\")\n\nsystem.time(\n  listOpport <- PointsToOpportunity(spatpts = spatPts, mask = spaceBound, resolution = 200, typedist = \"euclidean\", typefct = \"exponential\", beta = 2, span = 500, varname = \"EFF\")\n)\n\nsystem.time(\n  polyPot <- OpportunityToPotentials(unknownpts = listOpport$UNKNW, matopport = listOpport$OPPORT, nbclass = 5, mask = spaceBound)\n)\n\nsmoothedPol <- gBuffer(\n  gBuffer(spgeom = polyPot, width = 150, byid = TRUE, capStyle = \"ROUND\", joinStyle = \"ROUND\"),\n  byid = TRUE, width = -150, capStyle = \"ROUND\", joinStyle = \"ROUND\")\n\n\nplot(smoothedPol)\n\n\nwriteOGR(obj = bibi, dsn = \"test3\", layer = \"myPotentials\", driver = \"ESRI Shapefile\")\nwriteRaster(x = rasterClip, filename = \"myraster\", format=\"GTiff\")\n\n\nPointsToOpportunity <- function(spatpts, mask, resolution, typedist, typefct, beta, span, varname)\n{\n  unknownpts <- CreateGrid(spatpts = spatpts, mask = mask, resolution = resolution)\n  matdist <- GetDistMat(knownpts = spatpts, unknownpts = unknownpts, typedist = typedist)\n  getinteract <- ComputeInteractDensity(matdist = matdist, unknownpts = unknownpts, typefct = typefct, beta = beta, span = span)\n  unknownpts <- getinteract[[1]]\n  matdens <- getinteract[[2]]\n  matopport <- ComputeOpportunity(knownpts = spatpts, matdens = matdens, varname = varname)\n  return(list(UNKNW = unknownpts, OPPORT = matopport))\n}\n\nOpportunityToPotentials <- function(unknownpts, matopport, nbclass, mask)\n{\n  polyPot <- ComputePotentials(unknownpts = unknownpts, matopport = matopport, nbclass = nbclass, mask = mask, myproj = proj4string(mask))\n  return(polyPot)\n}\n\n# Create grid of unknown points ----\n\nCreateGrid <- function (spatpts, mask, resolution)\n{\n  coordPts <- data.frame(COORDX = coordinates(spatpts)[, 1], COORDY = coordinates(spatpts)[, 2], stringsAsFactors = FALSE)\n  spatSteps <- ifelse(max(coordPts[ , \"COORDX\"]) - min(coordPts[ , \"COORDX\"]) >= max(coordPts[ , \"COORDY\"]) - min(coordPts[ , \"COORDY\"]),\n                      round((max(coordPts[ , \"COORDX\"]) - min(coordPts[ , \"COORDX\"])) / resolution, digits = 4),\n                      round((max(coordPts[ , \"COORDY\"]) - min(coordPts[ , \"COORDY\"])) / resolution, digits = 4))\n  \n  boundingBox <- bbox(mask)\n  boxCoordX <- round(seq(boundingBox[1, 1] - spatSteps, boundingBox[1, 2] + spatSteps, spatSteps), digits = 4)\n  boxCoordY <- round(seq(boundingBox[2, 1] - spatSteps, boundingBox[2, 2] + spatSteps, spatSteps), digits = 4)\n  spatGrid <- expand.grid(boxCoordX, boxCoordY)\n  idSeq <- seq(1, nrow(spatGrid), 1)\n  spatGrid <- data.frame(ID = idSeq, COORDX = spatGrid[, 1], COORDY = spatGrid[, 2])\n  return(spatGrid)\n}\n\n\n\n# Compute matrix of distances ----\n\nGetDistMat <- function(knownpts, unknownpts, typedist)\n{\n  knownPts <- data.frame(COORDX = coordinates(knownpts)[, 1], COORDY = coordinates(knownpts)[, 2], stringsAsFactors = FALSE)\n  \n  if(typedist == \"euclidean\")\n  {\n    matDist <- rdist(knownPts[ , c(\"COORDX\", \"COORDY\")], unknownpts[ , c(\"COORDX\", \"COORDY\")])\n  }\n  \n  if(typedist == \"orthodromic\")\n  {\n    # x = longitud, y = latitud (decimal, WGS84)\n    mDistance <- rdist.earth(knownPts[ , c(\"COORDX\", \"COORDY\")], unknownpts[ , c(\"COORDX\", \"COORDY\")], miles = FALSE, R = NULL)\n  }\n  diag(matDist) <- 0 \n  return(round(matDist, digits = 8))\n}\n\n\n# Compute density of interaction ----\n\nComputeInteractDensity <- function(matdist, unknownpts, typefct, beta, span)\n{\n  if(typefct == \"pareto\")\n  {\n    alpha  <- (2 ^ (1 / beta) - 1) / span\n    matDens <- (1 + alpha * matdist) ^ (-beta)\n  }\n  \n  if(typefct == \"exponential\")\n  {\n    alpha  <- log(2) / span ^ beta\n    matDens <- exp(- alpha * matdist ^ beta)\n  }\n  \n  diag(matDens) <- 1\n  unknownpts$MAXDENSITY <- apply(matDens, 2, max, na.rm = TRUE)\n  \n  return(list(unknownpts, round(matDens, digits = 8)))\n}\n\n\n# Compute opportunities ----\n\nComputeOpportunity <- function(knownpts, matdens, varname = varname)\n{\n  matOpport <- knownpts@data[, varname] * matdens\n  return(round(matOpport, digits = 8))\n}\n\n\n# Compute potentials (with mask) ----\n\nComputePotentials <- function(unknownpts, matopport, nbclass, mask, myproj)\n{\n  # compute potentials and create raster\n  unknownpts$POTENTIALS <- apply(matopport, 2, sum, na.rm = TRUE)\n  equalInterval <- (max(unknownpts$POTENTIALS) - min(unknownpts$POTENTIALS)) / nbclass\n  brksVal <- seq(min(unknownpts$POTENTIALS), max(unknownpts$POTENTIALS), equalInterval)\n  \n  unknownpts$POTDISCRET <- as.integer(cut(unknownpts$POTENTIALS, breaks = brksVal,\n                                          labels = seq(1, nbclass, 1), right = FALSE, include.lowest = TRUE))\n  \n  spatUnknownPts <- SpatialPointsDataFrame(coords = unknownpts[ , c(2, 3)], \n                                           data = unknownpts, proj4string = CRS(myproj))\n  \n  rastGrid <- raster(xmn = min(unknownpts$COORDX), \n                     xmx = max(unknownpts$COORDX),\n                     ymn = min(unknownpts$COORDY),\n                     ymx = max(unknownpts$COORDY),\n                     nrows = length(unique(unknownpts$COORDY)),\n                     ncols = length(unique(unknownpts$COORDX)))\n  \n  rRaster <- rasterize(spatUnknownPts, rastGrid, field = \"POTDISCRET\")\n  rasterClip <- mask(rRaster, mask = mask)\n  \n  polyPot <- rasterToPolygons(rasterClip, n = 8, digits = 24, dissolve = TRUE)\n  #polyPot <- gdal_polygonizeR(rRaster)\n  return(polyPot)\n}\n\ngdal_polygonizeR <- function(x, outshape = NULL, gdalformat = \"ESRI Shapefile\", pypath = NULL, readpoly = TRUE, quiet = TRUE) {\n  if (isTRUE(readpoly)) require(rgdal)\n  if (is.null(pypath)) {\n    pypath <- Sys.which('gdal_polygonize.py')\n  }\n  if (!file.exists(pypath)) stop(\"Can't find gdal_polygonize.py on your system.\")\n  owd <- getwd()\n  on.exit(setwd(owd))\n  setwd(dirname(pypath))\n  if (!is.null(outshape)) {\n    outshape <- sub('\\\\.shp$', '', outshape)\n    f.exists <- file.exists(paste(outshape, c('shp', 'shx', 'dbf'), sep='.'))\n    if (any(f.exists))\n      stop(sprintf('File already exists: %s',\n                   toString(paste(outshape, c('shp', 'shx', 'dbf'),\n                                  sep='.')[f.exists])), call.=FALSE)\n  } else outshape <- tempfile()\n  if (is(x, 'Raster')) {\n    require(raster)\n    writeRaster(x, {f <- tempfile(fileext='.asc')})\n    rastpath <- normalizePath(f)\n  } else if (is.character(x)) {\n    rastpath <- normalizePath(x)\n  } else stop('x must be a file path (character string), or a Raster object.')\n  system2('python', args=(sprintf('\"%1$s\" \"%2$s\" -f \"%3$s\" \"%4$s.shp\"',\n                                  pypath, rastpath, gdalformat, outshape)))\n  if (isTRUE(readpoly)) {\n    shp <- readOGR(dirname(outshape), layer = basename(outshape), verbose=!quiet)\n    return(shp)\n  }\n  return(NULL)\n}\n\n\nlibrary(spgrass6)\ninitGRASS(gisBase = \"/usr/lib/grass64\", home = getwd(), override = TRUE)\nwriteVECT6(SDF = polyPot, vname = \"popol\", v.in.ogr_flags = c(\"o\", \"overwrite\"))\nexecGRASS(\"v.generalize\", flags = c(\"overwrite\"), input = \"popol\", output = \"polySimple\", threshold = 1, method = \"snakes\", alpha = 1, beta = 1)\nvivi <- readVECT6(vname = \"polySimple\")\nplot(vivi)\nplot(polyPot)\n\n# Discretize and map ----\n\nDiscretMap <- function(tabpot, nbclass = 8){\n  # create color palette and discretize\n  colPal <- rev(brewer.pal(n = nbclass, name = \"RdYlBu\"))\n  tabpot$POTDISCRET <- as.character(cut(tabpot$POTENTIALS, \n                                        breaks = quantile(tabpot$POTENTIALS, probs = seq(0, 1, 1/nbclass)), \n                                        labels = paste(\"QUANT_\", seq(1, nbclass, 1)), right = FALSE, include.lowest = TRUE))\n  \n  # create map\n  printMap <- ggplot(tabpot) +\n    geom_raster(aes(x = COORDX, y = COORDY, fill = POTDISCRET)) +\n    coord_equal() + scale_fill_manual(values = colPal) + theme_bw()\n  \n  return(printMap)\n}\n\n\n\n",
    "created" : 1421945466480.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "986300488",
    "id" : "13D54E2D",
    "lastKnownWriteTime" : 1421942038,
    "path" : "~/Repositories/StewartPotentials/old_fct.R",
    "project_path" : "old_fct.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}